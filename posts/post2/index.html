<!DOCTYPE html><html lang="zh"> <head><meta charset="UTF-8"><title>k邻近法</title><!-- KaTeX CSS --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><style>*{box-sizing:border-box}body{margin:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";line-height:1.7;background:#fafafa;color:#222}main{max-width:760px;margin:3rem auto;padding:0 1.2rem}header{margin-bottom:2rem}header a{text-decoration:none;color:#222;font-weight:600}.site-header{border-bottom:1px solid #eee;background:#fff}.nav-container{max-width:960px;margin:0 auto;padding:1rem 1.2rem;display:flex;justify-content:space-between;align-items:center}.logo{font-weight:700;font-size:1.05rem;text-decoration:none;color:#111}.nav-links{display:flex;gap:1.5rem}.nav-links a{font-size:.95rem;text-decoration:none;color:#444;border-bottom:1px solid transparent;transition:color .2s ease,border-color .2s ease}.nav-links a:hover{color:#2563eb;border-bottom-color:currentColor}h1,h2,h3{line-height:1.3}h1{margin-bottom:1.2rem}h2{margin-top:2.5rem}article p{margin:1rem 0}article ul{padding-left:1.4rem}article li{margin:.4rem 0}pre{background:#f4f4f4;padding:1rem;overflow-x:auto;border-radius:6px}code{background:#f4f4f4;padding:.2em .4em;border-radius:4px;font-size:.95em}.katex{font-size:1.05em}a{color:#00040c;text-decoration:none;border-bottom:1px solid transparent;transition:border-color .2s ease,color .2s ease}a:hover{color:#274ecf;border-bottom-color:currentColor}.home-intro{margin-bottom:3rem}.home-intro h1{margin-bottom:.5rem}.home-intro p{color:#555;max-width:600px}.home-posts h2{margin-bottom:1rem;font-size:1.2rem;color:#333}.home-posts ul{list-style:none;padding:0;margin:0}.post-item{display:flex;justify-content:space-between;align-items:baseline;padding:.6rem 0;border-bottom:1px solid #eee}.post-item a{font-weight:500}.post-date{font-size:.85rem;color:#888}.post-title{font-weight:700;font-size:1.2rem}.post-date{display:block;font-size:.9rem;color:#666}.post-abstract{margin-top:.5rem;color:#333}.post-grid{display:grid;gap:1.8rem}.post-card{display:block;padding:1.6rem;border-radius:12px;border:1px solid #e5e7eb;text-decoration:none;color:inherit;background:#fff;transition:all .2s ease}.post-card:hover{transform:translateY(-4px);box-shadow:0 10px 25px #00000014;border-color:#d1d5db}.post-meta{font-size:.85rem;color:#9ca3af}.post-layout{display:grid;grid-template-columns:minmax(0,1fr) 220px;gap:2.5rem;align-items:start}.post-content{min-width:0}.post-toc{position:sticky;top:2rem;font-size:.9rem;color:#444}.post-toc nav{border-left:2px solid #e5e7eb;padding-left:1rem}.post-toc strong{display:block;margin-bottom:.6rem;font-weight:600}.post-toc ul{list-style:none;padding:0;margin:0}.post-toc li{margin:.35rem 0}.post-toc li.depth-3{padding-left:1rem}.post-toc li.depth-4{padding-left:2rem}.post-toc a{color:#555;border-bottom:none}.post-toc a:hover{color:#2563eb}@media(max-width:1024px){.post-layout{grid-template-columns:1fr}.post-toc{position:static;margin-bottom:2rem;order:-1;border-left:none;padding-left:0}.post-toc nav{background:#f3f4f6;padding:1rem;border-radius:8px}}
</style></head> <body> <header class="site-header"> <div class="nav-container"> <a href="/myblog/" class="logo">我的博客</a> <nav class="nav-links"> <a href="/archive">归档</a> <a href="/tags">标签</a> <a href="https://github.com/learning-up-up" target="_blank" rel="noopener">GitHub</a> </nav> </div> </header> <main>  <div class="post-layout"> <article class="post-content"> <h1>k邻近法</h1> <h1 id="k邻近法">k邻近法</h1>
<p>一种基本的分类回归方法，其并没有显示的学习过程。对于一个测试实例，通过训练集中距离最近的k个实例来进行表决，得到该实例的分类结果。</p>
<h2 id="模型">模型</h2>
<p>k邻近法的核心就是通过对于特征空间的划分，实现决策。其中重点要考虑的是距离度量、k值、表决方式</p>
<p>距离度量可以取p范数（常用2范数）</p>
<h3 id="k的取值">k的取值</h3>
<p>k如果过小，那么k值就会更加明显的受到最临近点的影响，倘若最邻近点就是噪声，那么分类结果就会出现较大的偏差。k过小会是模型变得复杂，过拟合的概率增加</p>
<p>k如果过大，考虑极限情况<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>k</mi><mo>=</mo><mi>N</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`k = N`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">‘</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">‘</span></span></span></span>，此时无论测试实例为什么，结果都是固定的。此时的模型过于简单</p>
<p>k一般还是去一个较小的值，通过交叉验证法来确定最佳的k值</p>
<h3 id="决策方式">决策方式</h3>
<p>通常使用多数最优的方式，考虑<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mn>0</mn><mo>−</mo><mn>1</mn><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`0-1`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">‘0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">1‘</span></span></span></span>损失函数，那么多数最优就是经验风险最小化的情况</p>
<h2 id="kd树">kd树</h2>
<p>我们往往通过构造一个二叉树来实现对于k维特征空间的划分，称之为kd树，构造kd树的方法非常简单。</p>
<p>实际上我们就是在用垂直于坐标轴的超平面不断地去划分特征空间，步骤如下</p>
<ol>
<li>取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`x^{(1)}`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord">‘</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">‘</span></span></span></span>为坐标轴，取N个实例中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`x^{(1)}`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord">‘</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">‘</span></span></span></span>为中位数的为根节点，其中小于该中位数的为左子树，其余为右子树</li>
<li>对于深度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>j</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`j`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">‘</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mord">‘</span></span></span></span>的节点，取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`x^{(l)}`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.888em;"></span><span class="mord">‘</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord">‘</span></span></span></span>为坐标轴（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">‘</mi><mi>l</mi><mo>=</mo><mi>j</mi><mo stretchy="false">(</mo><mspace></mspace><mspace width="0.6667em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">`l = j (\mod k) + 1`</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">‘</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mopen">(</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">1‘</span></span></span></span>），重复的进行划分直到子区域中没有实例点</li>
</ol>
<h3 id="搜索">搜索</h3>
<ol>
<li>
<p>首先找到测试点所属的叶子节点：从根结点出发，按照对应坐标轴进行分类就得到此时的最邻近点</p>
</li>
<li>
<p>回溯：递归回退</p>
<ol>
<li>若该节点到测试点的距离更近，则更新最邻近点的值</li>
<li>检查另一子树内是否有更邻近的点，即检查以测试点为球心，最近距离为半径的超球体是否与该区域相交，若不相交，向上回退</li>
</ol>
</li>
<li>
<p>直到回退到根节点，此时最邻近的点就是结果</p>
</li>
</ol>
<p>对于最邻近的k个点，那么在回溯的过程中就要维护一个大顶堆，通过比较大顶堆堆顶的值来进行更新。</p>
<h2 id="总结">总结</h2>
<p>kNN适合小样本的训练，其可解释性较弱。适合一些简单的问题，应用范围不广。</p> </article> <aside class="post-toc"> <nav> <strong>目录</strong> <ul> <li class="depth-1"> <a href="#k邻近法">k邻近法</a> </li><li class="depth-2"> <a href="#模型">模型</a> </li><li class="depth-3"> <a href="#k的取值">k的取值</a> </li><li class="depth-3"> <a href="#决策方式">决策方式</a> </li><li class="depth-2"> <a href="#kd树">kd树</a> </li><li class="depth-3"> <a href="#搜索">搜索</a> </li><li class="depth-2"> <a href="#总结">总结</a> </li> </ul> </nav> </aside> </div>  </main> </body></html>